<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AR Game - Distortion Free</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* Mirror the container */
        #container {
            position: relative; width: 100vw; height: 100vh; transform: scaleX(-1); 
        }

        /* Hide raw elements */
        #video-feed, #cutout-canvas { display: none; }
        #three-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI Layer (Unmirrored) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; 
            pointer-events: none; z-index: 10;
        }
        #logo {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            width: min(280px, 45vw);
            pointer-events: none;
            z-index: 11;
        }

        #score-board {
            position: absolute; top: 20px; right: 20px;
            color: #e21690; font-size: 2.5rem; font-weight: 900;
            text-shadow: 2px 2px 0px #000;
            background: rgba(0, 0, 0, 0.6); padding: 10px 25px; border-radius: 15px; border: 2px solid #e21690;
        }
        #timer-board {
            position: absolute; top: 20px; left: 20px;
            color: #ffffff; font-size: 2.2rem; font-weight: 900;
            text-shadow: 2px 2px 0px #000;
            background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border-radius: 15px; border: 2px solid #ffffff;
        }
        #status {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; text-align: center;
            background: rgba(0,0,0,0.8); padding: 30px; border-radius: 20px;
        }
        #leaderboard {
            position: absolute; inset: 0;
            display: none; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            z-index: 12; pointer-events: none;
        }
        #leaderboard-card {
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #e21690;
            border-radius: 20px;
            padding: 30px 40px;
            color: #ffffff;
            min-width: min(420px, 80vw);
            text-align: center;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
        }
        #leaderboard-card h2 {
            margin: 0 0 15px;
            font-size: 2rem;
            color: #e21690;
            text-shadow: 2px 2px 0 #000;
        }
        #leaderboard-card p {
            margin: 0 0 20px;
            font-size: 1.1rem;
        }
        #leaderboard-form {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        #initials-input {
            border-radius: 10px;
            border: 2px solid #e21690;
            padding: 8px 12px;
            font-size: 1rem;
            text-transform: uppercase;
            max-width: 120px;
            text-align: center;
        }
        #initials-submit {
            border-radius: 10px;
            border: none;
            padding: 8px 16px;
            font-size: 1rem;
            font-weight: 700;
            color: #0c0c0c;
            background: #e21690;
            cursor: pointer;
        }
        #leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 10px;
            text-align: left;
        }
        #leaderboard-list li {
            display: flex;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 600;
        }
    </style>
    
    <!-- AI Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="container">
        <video id="video-feed" autoplay muted playsinline></video>
        <canvas id="cutout-canvas"></canvas>
        <canvas id="three-canvas"></canvas>
    </div>

    <div id="ui-layer">
        <img id="logo" alt="Game logo" aria-hidden="true" />
        <div id="timer-board">1:00</div>
        <div id="score-board">0</div>
        <div id="status">Starting Camera...</div>
        <div id="leaderboard">
            <div id="leaderboard-card">
                <h2>Leaderboard</h2>
                <p id="leaderboard-score"></p>
                <form id="leaderboard-form">
                    <input id="initials-input" maxlength="3" placeholder="ABC" autocomplete="off" />
                    <button id="initials-submit" type="submit">Save</button>
                </form>
                <ol id="leaderboard-list"></ol>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        // Point to a PNG logo placed next to this file; falls back to a generated asset if missing.
        const CUSTOM_LOGO_PATH = './logo.png';
        const MOLE_MODEL_URL = 'penis.glb';
        const BG_MODEL_URL = './background.glb';
        const GAMEPLAY_CONFIG = {
            spawnRateMs: 1200,
            enterSpeed: 1.75,
            leaveSpeed: 1.75,
            waitDurationMs: 1000,
            moleScale: 0.5,
            maxActiveMoles: 6
        };
        const BG_SCALE = 3.0; // Increased to cover wider screens
        const BACKGROUND_MUSIC_URL = 'backgroundsong.mp3';
        const HIT_SOUND_URL = 'trigger.mp3';
        const BACKGROUND_MUSIC_VOLUME = 0.25;
        const HIT_SOUND_VOLUME = 0.6;

        const GRAB_THRESHOLD = 0.08;
        const HIT_RADIUS = 0.2;
        const SPAWN_RATE = GAMEPLAY_CONFIG.spawnRateMs;
        const MIN_MOLE_SEPARATION = 0.6;
        const HIT_EFFECT_DURATION = 12;
        const HIT_SCALE_MULTIPLIER = 1.6;
        const GAME_DURATION_SECONDS = 60;
        const LEADERBOARD_SIZE = 5;

        // --- Globals ---
        let score = 0;
        let objects = [];
        let lastSpawnTime = 0;
        let lastFrameTime = null;
        let moleModel = null;
        let handResults = null;
        let moleHitRadius = HIT_RADIUS;
        let fallbackHitRadius = HIT_RADIUS;
        let screenAspect = window.innerWidth / window.innerHeight;
        let timeRemaining = GAME_DURATION_SECONDS;
        let timerInterval = null;
        let gameActive = true;
        const audioState = {
            background: null,
            hit: null,
            enabled: false
        };

        const DEFAULT_LOGO_DATA_URL = (() => {
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 80;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e21690';
            ctx.font = 'bold 32px "Segoe UI", system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 6;
            ctx.fillText('GAME LOGO', canvas.width / 2, canvas.height / 2);

            return canvas.toDataURL('image/png');
        })();

        const scoreElement = document.getElementById('score-board');
        const timerElement = document.getElementById('timer-board');
        const statusElement = document.getElementById('status');
        const videoElement = document.getElementById('video-feed');
        const canvasElement = document.getElementById('three-canvas');
        const cutoutCanvas = document.getElementById('cutout-canvas');
        const cutoutCtx = cutoutCanvas.getContext('2d');
        const logoElement = document.getElementById('logo');
        const leaderboardElement = document.getElementById('leaderboard');
        const leaderboardScoreElement = document.getElementById('leaderboard-score');
        const leaderboardListElement = document.getElementById('leaderboard-list');
        const leaderboardForm = document.getElementById('leaderboard-form');
        const initialsInput = document.getElementById('initials-input');
        const maxActiveMoles = GAMEPLAY_CONFIG.maxActiveMoles;

        logoElement.onerror = () => {
            logoElement.onerror = null;
            logoElement.src = DEFAULT_LOGO_DATA_URL;
        };
        logoElement.src = CUSTOM_LOGO_PATH || DEFAULT_LOGO_DATA_URL;
        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        
        // FIX: Camera respects screen aspect ratio
        // Y is fixed from -1 to 1. X scales based on aspect.
        const camera = new THREE.OrthographicCamera(-screenAspect, screenAspect, 1, -1, 0.1, 100);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: false, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(0, 5, 10);
        scene.add(dirLight);

        // --- Load Models ---
        const loader = new GLTFLoader();

        loader.load(MOLE_MODEL_URL, (gltf) => {
            moleModel = gltf.scene;
            moleModel.traverse(c => { if(c.isMesh) c.material.side = THREE.DoubleSide; });

            const bounds = new THREE.Box3().setFromObject(moleModel);
            const sphere = new THREE.Sphere();
            bounds.getBoundingSphere(sphere);
            moleHitRadius = sphere.radius * GAMEPLAY_CONFIG.moleScale * 1.05; // small padding
        });

        loader.load(BG_MODEL_URL, (gltf) => {
            const bgModel = gltf.scene;
            bgModel.scale.set(BG_SCALE, BG_SCALE, BG_SCALE);
            bgModel.position.z = -10; 
            bgModel.position.y = -2;
            scene.add(bgModel);
        });

        // --- The User Plane (Distortion Fix) ---
        
        const cutoutTexture = new THREE.CanvasTexture(cutoutCanvas);
        cutoutTexture.colorSpace = THREE.SRGBColorSpace;
        cutoutTexture.minFilter = THREE.LinearFilter;

        // Start with a 1x1 plane, we will scale it dynamically
        const userGeometry = new THREE.PlaneGeometry(1, 1); 
        const userMaterial = new THREE.MeshBasicMaterial({
            map: cutoutTexture,
            transparent: true,
            side: THREE.DoubleSide
        });
        const userPlane = new THREE.Mesh(userGeometry, userMaterial);
        userPlane.position.z = -2;
        scene.add(userPlane);

        // Function to ensure video fills screen without stretching (Cover Mode)
        function resizeUserPlane() {
            if (videoElement.videoWidth === 0) return;

            // 1. Update Camera Aspect
            screenAspect = window.innerWidth / window.innerHeight;
            camera.left = -screenAspect;
            camera.right = screenAspect;
            camera.top = 1;
            camera.bottom = -1;
            camera.updateProjectionMatrix();

            // 2. Calculate "Cover" Scale
            // View Height is fixed at 2 units (Top 1 to Bottom -1)
            // View Width is 2 * screenAspect
            const viewHeight = 2;
            const viewWidth = 2 * screenAspect;
            
            const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
            
            // Determine scale to cover the view
            let scaleX, scaleY;

            // If screen is wider than video, fit to width
            if (screenAspect > videoAspect) {
                scaleX = viewWidth;
                scaleY = viewWidth / videoAspect;
            } else {
                // Screen is taller than video, fit to height
                scaleY = viewHeight;
                scaleX = viewHeight * videoAspect;
            }

            userPlane.scale.set(scaleX, scaleY, 1);
        }

        // --- Audio ---
        function setupAudio() {
            if (audioState.background && audioState.hit) return;
            const background = new Audio(BACKGROUND_MUSIC_URL);
            background.loop = true;
            background.volume = BACKGROUND_MUSIC_VOLUME;
            background.preload = 'auto';

            const hit = new Audio(HIT_SOUND_URL);
            hit.volume = HIT_SOUND_VOLUME;
            hit.preload = 'auto';

            audioState.background = background;
            audioState.hit = hit;
        }

        function enableAudio() {
            if (audioState.enabled) return;
            setupAudio();
            if (!audioState.background || !audioState.hit) return;
            audioState.enabled = true;
            audioState.background.play().catch(() => {
                audioState.enabled = false;
            });
        }

        function playHitSound() {
            if (!audioState.enabled || !audioState.hit) return;
            audioState.hit.currentTime = 0;
            audioState.hit.play().catch(() => {});
        }

        // --- AI Logic ---
        
        function onSegmentationResults(results) {
            // Update Canvas Size if it changed (e.g. webcam started)
            if (cutoutCanvas.width !== videoElement.videoWidth) {
                cutoutCanvas.width = videoElement.videoWidth;
                cutoutCanvas.height = videoElement.videoHeight;
                resizeUserPlane(); // Recalculate aspect ratio
            }

            cutoutCtx.clearRect(0, 0, cutoutCanvas.width, cutoutCanvas.height);
            
            // Draw Mask
            cutoutCtx.globalCompositeOperation = 'source-over';
            cutoutCtx.drawImage(results.segmentationMask, 0, 0, cutoutCanvas.width, cutoutCanvas.height);

            // Composite Video
            cutoutCtx.globalCompositeOperation = 'source-in';
            cutoutCtx.drawImage(videoElement, 0, 0, cutoutCanvas.width, cutoutCanvas.height);
            
            // Reset
            cutoutCtx.globalCompositeOperation = 'source-over';
            cutoutTexture.needsUpdate = true;
        }

        async function startApp() {
            const segmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`});
            segmentation.setOptions({ modelSelection: 1 });
            segmentation.onResults(onSegmentationResults);

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults((results) => { handResults = results; });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await segmentation.send({image: videoElement});
                    await hands.send({image: videoElement});
                    statusElement.style.display = 'none';
                    renderLoop();
                },
                width: 1280,
                height: 720
            });
            await cameraUtils.start();
            startTimer();
            enableAudio();
        }

        // --- Game Logic ---

        function createMole() {
            let mole;
            let isGlb = false;
            let baseScale = 1;
            let hitRadius = HIT_RADIUS;

            if (moleModel) {
                mole = moleModel.clone();
                mole.scale.set(GAMEPLAY_CONFIG.moleScale, GAMEPLAY_CONFIG.moleScale, GAMEPLAY_CONFIG.moleScale);
                isGlb = true;
                baseScale = GAMEPLAY_CONFIG.moleScale;
                hitRadius = moleHitRadius;
            } else {
                const geometry = new THREE.CapsuleGeometry(0.1, 0.3, 4, 8);
                geometry.computeBoundingSphere();
                fallbackHitRadius = (geometry.boundingSphere?.radius || HIT_RADIUS) * 1.05;
                const material = new THREE.MeshStandardMaterial({ color: 0xff4444 });
                mole = new THREE.Mesh(geometry, material);
                mole.rotation.z = Math.PI / 2;
                baseScale = 1;
                hitRadius = fallbackHitRadius;
            }

            // DYNAMIC SPAWN POINTS: Use Camera Edges
            // camera.right is the exact edge of the screen in 3D units
            const screenEdge = camera.right;

            const sideFactor = Math.random() > 0.5 ? 1 : -1;

            // Start off-screen by at least the mole radius so it emerges naturally
            const startX = sideFactor * (screenEdge + hitRadius);

            // Keep roughly 20% of the model off-canvas by stopping 60% of the radius inside the view
            const targetX = sideFactor * (screenEdge - hitRadius * 0.6);

            // Keep trying to find a clear spawn position to avoid overlaps
            let spawnY = 0;
            let attempts = 0;
            do {
                spawnY = (Math.random() * 1.5) - 0.75;
                attempts++;
            } while (!isSpawnClear(targetX, spawnY, hitRadius) && attempts < 10);

            mole.position.x = startX;
            mole.position.y = spawnY;
            mole.position.z = 0;

            if (isGlb) mole.rotation.y = sideFactor === 1 ? -Math.PI / 2 : Math.PI / 2;

            mole.userData = { 
                state: 'ENTERING', startX: startX, targetX: targetX,
                side: sideFactor, waitTimer: 0, waitStart: null, isGlb: isGlb,
                hitTimer: 0, baseScale: baseScale,
                hitRadius: isGlb ? moleHitRadius : fallbackHitRadius
            };
            scene.add(mole);
            objects.push(mole);
        }

        function isSpawnClear(targetX, targetY, newHitRadius) {
            return objects.every((obj) => {
                const existingTarget = obj.userData.targetX ?? obj.position.x;
                const existingY = obj.position.y;
                const existingRadius = obj.userData.hitRadius ?? HIT_RADIUS;

                const padding = Math.max(MIN_MOLE_SEPARATION, Math.max(existingRadius, newHitRadius) * 0.3);
                const requiredSeparation = existingRadius + newHitRadius + padding;

                const dxTarget = targetX - existingTarget;
                const dyTarget = targetY - existingY;
                const targetDistance = Math.hypot(dxTarget, dyTarget);

                const dxCurrent = targetX - obj.position.x;
                const dyCurrent = targetY - obj.position.y;
                const currentDistance = Math.hypot(dxCurrent, dyCurrent);

                return targetDistance >= requiredSeparation && currentDistance >= requiredSeparation;
            });
        }

        function updateMoleVisuals(mole, state) {
            let colorHex = 0x000000;
            if (state === 'hover') colorHex = 0x555555;
            if (state === 'hit') colorHex = 0xff66ff;
            mole.traverse((child) => {
                if (child.isMesh) {
                    child.material.emissive.setHex(colorHex);
                    if (!mole.userData.isGlb) {
                         if (state === 'waiting') child.material.color.setHex(0x00ff00);
                         else if (state === 'leaving') child.material.color.setHex(0xff4444);
                         else if (state === 'hit') child.material.color.setHex(0xff66ff);
                    }
                }
            });
        }

        function updateMoles(deltaSeconds) {
            for (let i = objects.length - 1; i >= 0; i--) {
                const mole = objects[i];
                const data = mole.userData;

                if (data.state === 'ENTERING') {
                    mole.position.x -= data.side * (GAMEPLAY_CONFIG.enterSpeed * deltaSeconds);
                    
                    const reached = (data.side === 1 && mole.position.x <= data.targetX) || 
                                    (data.side === -1 && mole.position.x >= data.targetX);
                    if (reached) {
                        mole.position.x = data.targetX;
                        data.state = 'WAITING';
                        data.waitStart = performance.now();
                        updateMoleVisuals(mole, 'waiting');
                    }
                } else if (data.state === 'WAITING') {
                    data.waitTimer++;
                    if(data.isGlb) mole.rotation.z = Math.sin(Date.now() / 200) * 0.1;
                    else mole.rotation.x += 0.1;

                    const elapsedWait = data.waitStart ? (performance.now() - data.waitStart) : 0;
                    if (elapsedWait >= GAMEPLAY_CONFIG.waitDurationMs) {
                        data.state = 'LEAVING';
                        updateMoleVisuals(mole, 'leaving');
                    }
                } else if (data.state === 'LEAVING') {
                    mole.position.x += data.side * (GAMEPLAY_CONFIG.leaveSpeed * deltaSeconds);
                    // Remove if passed start position (off-screen)
                    const offScreen = (data.side === 1 && mole.position.x > data.startX) ||
                                      (data.side === -1 && mole.position.x < data.startX);
                    if (offScreen) {
                        scene.remove(mole);
                        objects.splice(i, 1);
                    }
                } else if (data.state === 'HIT') {
                    data.hitTimer++;
                    const progress = data.hitTimer / HIT_EFFECT_DURATION;
                    const scale = THREE.MathUtils.lerp(1, HIT_SCALE_MULTIPLIER, progress);
                    mole.scale.setScalar(scale * data.baseScale);
                    updateMoleVisuals(mole, 'hit');
                    if (data.hitTimer >= HIT_EFFECT_DURATION) {
                        scene.remove(mole);
                        objects.splice(i, 1);
                    }
                }
            }
        }

        function checkInteractions() {
            if (!gameActive) return;
            if (!handResults || !handResults.multiHandLandmarks) return;

            for (const landmarks of handResults.multiHandLandmarks) {
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                
                // Map Hand Coordinates (0 to 1) to Camera Frustum (-Aspect to +Aspect)
                // Note: X is inverted because of the CSS mirror scaleX(-1), but we must match logic
                const screenEdge = camera.right;
                
                // Since container is mirrored: Left hand in video appears on Right side of screen.
                // MediaPipe X=0 is Left (which becomes Right visually).
                // Let's stick to standard math: 
                // Normalized X (0..1) -> Screen X (-Aspect..Aspect)
                // MediaPipe x=0 is left edge of image. 
                
                const handX = (indexTip.x * 2 - 1) * screenEdge; 
                const handY = -(indexTip.y * 2 - 1); // Top is 1, Bottom is -1

                for (let i = objects.length - 1; i >= 0; i--) {
                    const mole = objects[i];
                    const hitRadius = mole.userData.hitRadius ?? HIT_RADIUS;
                    const dist = Math.hypot(handX - mole.position.x, handY - mole.position.y);

                    if (dist < hitRadius) {
                        if (mole.userData.state !== 'LEAVING' && mole.userData.state !== 'HIT') updateMoleVisuals(mole, 'hover');
                        if (pinchDist < GRAB_THRESHOLD && mole.userData.state !== 'HIT') {
                            score++;
                            scoreElement.innerText = score;
                            mole.userData.state = 'HIT';
                            mole.userData.hitTimer = 0;
                            updateMoleVisuals(mole, 'hit');
                            playHitSound();
                        }
                    } else {
                        if (mole.userData.state !== 'HIT') updateMoleVisuals(mole, 'normal');
                    }
                }
            }
        }

        function renderLoop() {
            if (!gameActive) {
                if (lastFrameTime === null) {
                    lastFrameTime = performance.now();
                }
                const now = performance.now();
                const deltaSeconds = (now - lastFrameTime) / 1000;
                lastFrameTime = now;
                updateMoles(deltaSeconds);
                renderer.render(scene, camera);
                return;
            }
            const now = performance.now();
            if (lastFrameTime === null) {
                lastFrameTime = now;
            }
            const deltaSeconds = (now - lastFrameTime) / 1000;
            lastFrameTime = now;
            if (now - lastSpawnTime > SPAWN_RATE && objects.length < maxActiveMoles) {
                createMole();
                lastSpawnTime = now;
            }
            updateMoles(deltaSeconds);
            checkInteractions();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeUserPlane();
        });

        // Start
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            timerElement.innerText = formatTime(timeRemaining);
        }

        function getLeaderboardScores() {
            const raw = localStorage.getItem('leaderboardScores');
            if (!raw) return [];
            try {
                const parsed = JSON.parse(raw);
                return Array.isArray(parsed) ? parsed : [];
            } catch {
                return [];
            }
        }

        function saveLeaderboardScores(scores) {
            localStorage.setItem('leaderboardScores', JSON.stringify(scores));
        }

        function updateLeaderboard(initials = '---') {
            const scores = getLeaderboardScores();
            const entry = {
                score,
                initials,
                date: new Date().toISOString()
            };
            scores.push(entry);
            scores.sort((a, b) => b.score - a.score);
            const topScores = scores.slice(0, LEADERBOARD_SIZE);
            saveLeaderboardScores(topScores);

            leaderboardScoreElement.innerText = `Your score: ${score}`;
            leaderboardListElement.innerHTML = '';
            topScores.forEach((item, index) => {
                const li = document.createElement('li');
                const label = document.createElement('span');
                const value = document.createElement('span');
                label.innerText = `${index + 1}. ${item.initials || '---'}`;
                value.innerText = item.score;
                li.append(label, value);
                leaderboardListElement.appendChild(li);
            });
        }

        function endGame() {
            gameActive = false;
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timeRemaining = 0;
            updateTimerDisplay();
            statusElement.innerText = "Time's up!";
            statusElement.style.display = 'block';
            objects.forEach((mole) => {
                if (mole.userData.state !== 'HIT') {
                    mole.userData.state = 'LEAVING';
                    updateMoleVisuals(mole, 'leaving');
                }
            });
            updateLeaderboard();
            leaderboardElement.style.display = 'flex';
            initialsInput.value = '';
            initialsInput.focus();
        }

        function startTimer() {
            updateTimerDisplay();
            timerInterval = window.setInterval(() => {
                if (!gameActive) return;
                timeRemaining -= 1;
                updateTimerDisplay();
                if (timeRemaining <= 0) {
                    endGame();
                }
            }, 1000);
        }

        startApp();
        window.addEventListener('pointerdown', enableAudio, { once: true });
        window.addEventListener('keydown', enableAudio, { once: true });

        leaderboardForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!leaderboardElement || leaderboardElement.style.display !== 'flex') return;
            const rawInitials = initialsInput.value.trim().slice(0, 3).toUpperCase();
            const initials = rawInitials.length > 0 ? rawInitials : '---';
            updateLeaderboard(initials);
            initialsInput.value = '';
        });

    </script>
</body>
</html>
